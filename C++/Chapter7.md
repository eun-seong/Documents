# [Chapter 7] 상속 심화
## 용어
`virtual` : 가상 함수 예약어   
가상함수 : `virtual` 예약을 앞에 붙여 선언한 메소드   
추상자료형 : 상위 크래스로 하위 파생 클래스를 참조할 때의 상위 클래스 형식    
`vtable` : 가상 함수 테이블, 함수 포인터 배열   
순수 가상 함수 : 선언은 지금 해두지만 정의는 미래에 하도록 미뤄둔 함수   
순수 가상 클래스 : 순수 가상 함수를 멤버로 가진 클래스    
* * *
## 가상 함수
`virtual` 예약어를 앞에 붙여서 선언한 메소드   
```c++
virtual 반환형식 메소드이름
virtual void PrintData();
```
* 파생 형식에서 메소드를 재정의하면 과거의 정의가 완전히 **무시**된다.   
    ***미래* 의 함수를 호출하는 것..!**
* 참조 형식이 무엇이든 **실 형식**의 메소드를 호출한다.
    - 일반 메소드의 경우 실형식은 중요하지 않고 **참조 형식**이 무엇인지에 따라 어떤 메소드가 호출되는지 결정된다.
* 가상함수는 호출하는 것이 아니라 **호출되는 것**이다.   
    과거에 만들어진 가상함수가 미래에 만들어질 코드로 호출될 수 있음
* 상속관계에서 기본 형식이 가상 클래스이면 파생 클래스의 소멸자는 가상 함수로 선언하지 않아도 자동으로 가상화된다.   

~~몽땅 다 내 손으로 만들어내는 것에 익숙한 사람 it's me...~~   
~~이 말은 다른 사람이랑 협업 잘 못한다는 말 아니냐고...~~

#### 재정의 막고 싶으면
`final` 예약어 사용
```c++
virtual void PrintData() final;
```
### 소멸자 가상화
추상자료형을 이용해서 동적 생성한 객체를 참조하면 파생 형식의 소멸자가 호출되지 않는다.    
=> 기본 클래스의 소멸자를 가상 함수로 선언   
* * *
## 가상 함수 테이블(vtable)
클래스에서 가상 함수가 있으면 `__vfptr` 포인터는 클래스의 가상 함수 테이블을 가르킨다.    
파생된 클래스가 있으면 기본 클래스의 가상 함수 테이블을 가르키다가 파생 클래스의 생성자가 생성될 때 파생 클래스의 가상 함수 테이블을 가르킨다.   
* late binding
* * *
## 순수 가상 클래스
* **순수 가상 함수**   
    선언은 지금 해두지만 정의는 미래에 하도록 미뤄둔 함수    
    ```c++
    virtual int GetData() const = 0;
    ```
* **순수 가상 클래스**   
    순수 가상 클래스의 파생 클래스는 **반드시** 기본 클래스의 순수 가상 함수를 재정의해야 한다.   
### 인터페이스 상속
❓ 순수 가상 클래스를 왜 쓰냐   
=> 다른 객체들과 상호작용을 위한 보편적인 인터페이스를 만들기 위해   

* * *
## 연습 문제
**Q1**   
순수 가상 클래스를 사용하여 다른 객체들과 상호작용을 위한 보편적인 인터페이스를 만들기 위해       
**Q2**   
상속받을 때   
**Q3**   
런타임에 함수의 주소가 결정되는 것   
**Q4**   
가상 함수들을 모두 재정의해야 한다.   
**Q5**   
파생 형식 클래스에 `virtual` 예약어를 함게 선언
